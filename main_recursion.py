# -*- coding: utf-8 -*-
"""
Created on Wed Jun 30 21:58:45 2021

@author: dc4204
"""

import numpy as np
import math
from collections import namedtuple



num_of_nodes = 9    # substitute len(Node_List) as generated by "create_graph.py"
# num_of_nodes != num_of_agents (connecting polygons are nodes but not agents)

edge_list = []
Phi_ = 0
d_ = 0
global lookup_table
#rot_table = [[1, 2, 0.0],
# [1, 3, 1.5707963267948966],
# [0, 1, 3.141592653589793],
# [0, 4, 2.0943951023931953],
# [0, 5, 1.0471975511965976],
# [0, 6, 0.0],
# [0, 7, -1.0471975511965976]] # substiture 'rot_table' as generated by "create_graph.py"
rot_table = [[0, 1, 2.0943951023931953],
 [2, 3, 0.0],
 [2, 4, 1.5707963267948966],
 [2, 5, 3.141592653589793],
 [0, 2, 3.141592653589793],
 [0, 6, 1.0471975511965976],
 [0, 7, 0.0],
 [0, 8, -1.0471975511965976]]


Agent = namedtuple("Agent", "field1 field2 field3")


def rotz(angle):
    return np.array([[math.cos(angle),-math.sin(angle),0],[math.sin(angle),math.cos(angle),0],[0,0,1]])

def get_rotation(row, col):
    global lookup_table
    return lookup_table[str(row)+str(col)]
    
def get_adjacency(E,num):
    #A = num*[num*[3*[0]]];   
    A = np.zeros([num,num,3], dtype = float); # initialize A matrix
    for edge in E:
        j = edge[0];
        i = edge[1];
        A[i][j] = edge[2];
        A[j][i] = edge[2];
    return A;

def account_node(node_num, exceptions_list, Phi_prev, D_prev, Adjacency):
    global num_of_agents
    global Agent_list
    global edge_list
    
    counter = 0
    exceptions_list.append(node_num)
    for i in range(num_of_nodes):
        w = Adjacency[node_num][i]
        if(sum(w)>0 and (i not in exceptions_list)):
            counter += 1
            Phi = Phi_prev + get_rotation(node_num, i)
            D = D_prev + np.matmul(rotz(Phi),np.array([-w[0],-w[1],w[2]]))
            account_node(i,exceptions_list, Phi, D, Adjacency)
        
    if(counter==0):
        #is leaf
        num_of_agents += 1
        if(Phi_prev<-math.pi):
            turns = int(abs(Phi_prev)/(2*math.pi))
            Phi_prev = Phi_prev + turns*2*math.pi 
        elif(Phi_prev>math.pi):
            turns = int(abs(Phi_prev)/(2*math.pi))
            Phi_prev = Phi_prev - (turns+1)*2*math.pi 
        Agent_list.append(Agent(num_of_agents, Phi_prev, D_prev))


if __name__== "__main__" :
    num_of_agents = 0
    Agent_list = []
    f_l_angle = 2.0943951023931953 # substitute 'f_l_num' from 'create_graph.py'

    global lookup_table
    lookup_table = {}
    for i in range(0,len(rot_table)):
        s = str(rot_table[i][0])+str(rot_table[i][1])
        lookup_table[s] = rot_table[i][2]
        
    
    l = 0.14;
    # Substiture the 'numeric_edge_list' generated by "create_graph.py"
    #edge_list = [[1,2,l],[1,3,l],[0,1,l],[0,4,l],[0,5,l],[0,6,l],[0,7,l]]  
    edge_list = [[0, 1, [0.14, 0, 0]],
 [2, 3, [0.14, 0, 0]],
 [2, 4, [0.14, 0, 0]],
 [2, 5, [0, 0, 0.06]],
 [0, 2, [0.14, 0, 0]],
 [0, 6, [0.14, 0, 0]],
 [0, 7, [0.14, 0, 0]],
 [0, 8, [0.14, 0, 0]]]
    Adjacency = get_adjacency(edge_list,num_of_nodes) 
    
    account_node(0, [], 0, np.array([0,0,0]), Adjacency)
    
    Final_Agent_list = []
    for agent in Agent_list:
        as_list = list(agent)
        d = agent[2]
        d_n = np.matmul(rotz(-f_l_angle+math.pi),d)
        as_list[2] = d_n
        as_list[1] += -f_l_angle + math.pi
        if(as_list[1]<-math.pi):
            turns = round(abs(as_list[1])/(2*math.pi))
            as_list[1] += turns*2*math.pi 
        elif(as_list[1]>math.pi):
            turns = round(abs(as_list[1])/(2*math.pi))
            as_list[1] -= (turns+1)*2*math.pi 
        Final_Agent_list.append(as_list)
    # Final output is the Final_Agent_list, which contains all copters, with their respective Displacement(d_i_xyz) and Rotation (s_i)
    # from the origin and with respect to the origin's reference frame
    